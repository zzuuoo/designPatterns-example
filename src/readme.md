## 设计模式六大原则
+  单一职责原则（Single Responsibility Principle，简称SRP ）

    + 核心思想：应该有且仅有一个原因引起类的变更

    + 问题描述：假如有类Class1完成职责T1，T2，当职责T1或T2有变更需要修改时，有可能影响到该类的另外一个职责正常工作。

    + 好处：类的复杂度降低、可读性提高、可维护性提高、扩展性提高、降低了变更引起的风险。

    + 需注意：单一职责原则提出了一个编写程序的标准，用“职责”或“变化原因”来衡量接口或类设计得是否优良，但是“职责”和“变化原因”都是不可以度量的，因项目和环境而异。


+  里氏替换原则（Liskov Substitution Principle,简称LSP）

    + 核心思想：在使用基类的的地方可以任意使用其子类，能保证子类完美替换基类。

    + 通俗来讲：只要父类能出现的地方子类就能出现。反之，父类则未必能胜任。

    + 好处：增强程序的健壮性，即使增加了子类，原有的子类还可以继续运行。

    + 需注意：如果子类不能完整地实现父类的方法，或者父类的某些方法在子类中已经发生“畸变”，则建议断开父子继承关系 采用依赖、聚合、组合等关系代替继承。


+  依赖倒置原则（Dependence Inversion Principle,简称DIP）

    + 核心思想：高层模块不应该依赖底层模块，二者都该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象；

    + 说明：高层模块就是调用端，低层模块就是具体实现类。抽象就是指接口或抽象类。细节就是实现类。

    + 通俗来讲：依赖倒置原则的本质就是通过抽象（接口或抽象类）使个各类或模块的实现彼此独立，互不影响，实现模块间的松耦合。

    + 问题描述：类A直接依赖类B，假如要将类A改为依赖类C，则必须通过修改类A的代码来达成。这种场景下，类A一般是高层模块，负责复杂的业务逻辑；类B和类C是低层模块，负责基本的原子操作；假如修改类A，会给程序带来不必要的风险。

    + 解决方案：将类A修改为依赖接口interface，类B和类C各自实现接口interface，类A通过接口interface间接与类B或者类C发生联系，则会大大降低修改类A的几率。

    + 好处：依赖倒置的好处在小型项目中很难体现出来。但在大中型项目中可以减少需求变化引起的工作量。使并行开发更友好。


+  接口隔离原则（Interface Segregation Principle,简称ISP）

    + 核心思想：类间的依赖关系应该建立在最小的接口上

    + 通俗来讲：建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少。也就是说，我们要为各个类建立专用的接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。

    + 问题描述：类A通过接口interface依赖类B，类C通过接口interface依赖类D，如果接口interface对于类A和类B来说不是最小接口，则类B和类D必须去实现他们不需要的方法。
    + 需注意：

        + 接口尽量小，但是要有限度。对接口进行细化可以提高程序设计灵活性，但是如果过小，则会造成接口数量过多，使设计复杂化。所以一定要适度

        + 提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情

        + 为依赖接口的类定制服务。只暴露给调用的类它需要的方法，它不需要的方法则隐藏起来。只有专注地为一个模块提供定制服务，才能建立最小的依赖关系。

+  迪米特法则（Law of Demeter,简称LoD）
    
    + 核心思想：类间解耦。

    + 通俗来讲： 一个类对自己依赖的类知道的越少越好。自从我们接触编程开始，就知道了软件编程的总的原则：低耦合，高内聚。无论是面向过程编程还是面向对象编程，只有使各个模块之间的耦合尽量的低，才能提高代码的复用率。低耦合的优点不言而喻，但是怎么样编程才能做到低耦合呢？那正是迪米特法则要去完成的。

+  开放封闭原则（Open Close Principle,简称OCP）

    + 核心思想：尽量通过扩展软件实体来解决需求变化，而不是通过修改已有的代码来完成变化

    + 通俗来讲： 一个软件产品在生命周期内，都会发生变化，既然变化是一个既定的事实，我们就应该在设计的时候尽量适应这些变化，以提高项目的稳定性和灵活性。

+ 一句话概括:单一职责原则告诉我们实现类要职责单一；里氏替换原则告诉我们不要破坏继承体系；依赖倒置原则告诉我们要面向接口编程；接口隔离原则告诉我们在设计接口的时候要精简单一；迪米特法则告诉我们要降低耦合。而开闭原则是总纲，他告诉我们要对扩展开放，对修改关闭。


##设计模式
+ 创建型
   + 简单工厂模式
     + 一个工厂类根据传入的参量决定创建出那一种产品类的实例。
   + 工厂方法模式
     + 定义一个创建对象的接口，让子类决定实例化那个类。
   + 抽象工厂模式
     + 创建相关或依赖对象的家族，而无需明确指定具体类。
   + 建造者模式
     + 封装一个复杂对象的构建过程，并可以按步骤构造。
   + 单例模式
     + 某个类只能有一个实例，提供一个全局的访问点。
   + 原型模式
     + 通过复制现有的实例来创建新的实例。
+ 行为型
   + 策略模式
     + 定义一系列算法，把他们封装起来，并且使它们可以相互替换。
   + 观察者模式
     + 对象间的一对多的依赖关系。
   + 责任链模式
     + 将请求的发送者和接收者解耦，使的多个对象都有处理这个请求的机会。
   + 命令模式
     + 将命令请求封装为一个对象，使得可以用不同的请求来进行参数化。
   + 状态模式
     + 允许一个对象在其对象内部状态改变时改变它的行为。
   + 模板模式
     + 定义一个算法结构，而将一些步骤延迟到子类实现。
   + 解释器模式
     + 给定一个语言，定义它的文法的一种表示，并定义一个解释器。
   + 备忘录模式
     + 在不破坏封装的前提下，保持对象的内部状态。
   + 中介者模式
     + 用一个中介对象来封装一系列的对象交互。  
   + 访问者模式
     + 在不改变数据结构的前提下，增加作用于一组对象元素的新功能。
   + 迭代器模式
     + 一种遍历访问聚合对象中各个元素的方法，不暴露该对象的内部结构。
   
+ 结构型
   + 适配器模式
     + 将一个类的方法接口转换成客户希望的另外一个接口。
   + 代理模式
     + 为其他对象提供一个代理以便控制这个对象的访问。
   + 装饰者模式
     + 动态的给对象添加新的功能。
   + 组合模式
     + 将对象组合成树形结构以表示“”部分-整体“”的层次结构。
   + 亨元（蝇量）模式
     + 通过共享技术来有效的支持大量细粒度的对象。
   
   + 外观模式
     + 对外提供一个统一的方法，来访问子系统中的一群接口。
   
   + 桥接模式
     + 将抽象部分和它的实现部分分离，使它们都可以独立的变化。